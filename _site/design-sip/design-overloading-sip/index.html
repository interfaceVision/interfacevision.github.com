
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Why We Don't Need Overloading</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Eric Hosick">

    <meta property="og:title" content="Interface Vision" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="http://www.interfacevision.com/assets/img/logoFinalStormyDaze122x260.png"/>
    <meta property="og:description" content=""/>
    <meta property="fb:admins" content="erichosick" />

    <link href='//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css' rel='stylesheet'>    
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <link href="http://fonts.googleapis.com/css?family=Pontano+Sans" rel="stylesheet" type="text/css">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>

  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/assets/img/logoFinalStormyDaze122x260.png"></img></a>
        </div>
      </div>
    </div>


    <div id="image-popup" class="modal hide fade">
      <div class="modal-body">
        <img id="image-to-show"></img>
      </div>
      <div class="modal-footer">
        <a href="#" class="btn btn-primary" data-dismiss="modal">Close</a>
      </div>
    </div>

    <div class="container marketing">
      
<div class="hero-unit">
  <h1 id='why_we_dont_use_overloading'>Why We Don&#8217;t Use Overloading</h1>

<h2 id='introduction'>Introduction</h2>

<p>We don&#8217;t use overloading because our framework has no subroutines to overload. This is because the rules of Simple Interface Programming (SIP) don&#8217;t allow subroutines with explicit parameters.</p>

<p>Instead of overloading, we use Parts that are able to operate on all primitives. Currently, we have chosen Part (aka object), string, boolean, integer, long, float, double, byte&#91;&#93;, int&#91;&#93;, long&#91;&#93; and float&#91;&#93; as the primitives we support.</p>

<h2 id='example_of_traditional_overloading'>Example of Traditional Overloading</h2>

<p>The following is how, traditionally, the function add would be defined for different primitives:</p>

<pre><code>...
int add (int left, int right ) { return left + right }
long add (long left, int right) { return left = right }
long add (long left, long right) { return left + right }
...</code></pre>

<p>and so on. The left and right parameters for add vary based on the primitives we need to add. This is known as overloading: specifically we have overloaded the subroutine add.</p>

<h2 id='how_we_overload_subroutines'>How We &#8220;Overload&#8221; Subroutines</h2>

<p>Our Part part use &#8220;with&#8221; Properties: each &#8220;with&#8221; property being of a different primitive data type. Here is the pseudo-code for our Part part (note we are only showing withPart, withInt and withFloat).</p>

<pre><code>[Serializable] public class Part : IPart {
  ...
  [XmlIgnore] public virtual IPart withPart { get; set; }
  [XmlIgnore] public virtual int   withInt { get; set; }
  [XmlIgnore] public virtual float withFloat { get; set; }
  ...
}</code></pre>

<p>By default, these properties do nothing for the set scope and return a &#8220;default value&#8221; for the get scope: usually 0, false, empty string, empty part and 0 length arrays.</p>

<p>Every Part that inherits from the Part class can optionally implement a &#8220;with&#8221; property.</p>

<p>Note: The Part class is our framework&#8217;s &#8220;object&#8221; from which everything inherits. At some point, we will update the C# object class to contain &#8220;with&#8221; properties.</p>

<h2 id='example_primitive_parts'>Example Primitive Parts</h2>

<p>Let&#8217;s look at pseudo-code for the Float and Integer part. Our Float and Integer parts implements the &#8220;with&#8221; properties as follows:</p>

<h3 id='float_part'>Float Part</h3>

<pre><code>namespace Vision.Core {

  [Serializable] public class Float : Part {
    protected float p_value = 0.0f;
    [XmlElement(&quot;value&quot;)] public override float withFloat {
      get { return p_value; }
      set { p_value = value; }
    }

    [XmlIgnore] public override int withInt {
      get { return (int)p_value; }
      set { p_value = value; }
    }
  }
}</code></pre>

<p>Our Float Part is able to convert to different primitive types automatically (note this is pseudo-code and more validation occurs in the actual source code).</p>

<p>Note: At some point we will update object of C# to contain with properties. The example Float part would be removed and the float type would be updated. This allows us to take advantage of boxing, etc.</p>

<h3 id='integer_part'>Integer Part</h3>

<p>The Integer Part looks almost similar to the Float part.</p>

<pre><code>namespace Vision.Core {
  [Serializable] public class Integer : Part {

    protected int p_value = 0;
    [XmlElement(&quot;value&quot;)] public override int withInt {
      get { return p_value; }
      set { p_value = value; }
    }

    [XmlIgnore] public override float withFloat {
      get { return (float)withInt; }
      set { withInt = (int)value; }
    }

  }
}</code></pre>

<h2 id='operations'>Operations</h2>

<p>So, we have our primitives defined. Let&#8217;s look at how we bypass the need for Overloading by implementing an Add Part.</p>

<h3 id='add_part'>Add Part</h3>

<pre><code>namespace Vision.Core {
  [Serializable] public class Add : OpArgDual {

    [XmlElement(&quot;argLeft&quot;)] public Part argLeft { get; set; }
    [XmlElement(&quot;argRight&quot;)] public Part argRight { get; set; }

    [XmlIgnore] public override int withInt {
      get { return argLeft.withInt + argRight.withInt; }
    }

    [XmlIgnore] public override float withFloat {
      get {
        return argLeft.withFloat + argRight.withFloat;
      }
    }

  }
}</code></pre>

<p>What is most interesting to note is that each &#8220;with&#8221; Property calls the associated &#8220;with&#8221; property of argLeft and argRight and then adds them. For example, withFloat is implemented as:</p>

<pre><code>return argLeft.withFloat + argRight.withFloat;</code></pre>

<h2 id='putting_it_all_together'>Putting it All Together</h2>

<p>Let&#8217;s see how we are able to use operations on different primitive types without Overloading. First, we will setup a few variables:</p>

<pre><code>...
IPart integerA = new Integer { withInt = 3 };
IPart integerB = new Integer { withInt = 4 };
IPart floatA = new Float { withFloat = 3.0f };
IPart floatB = new Float { withFloat = 3.0f };

IPart addTwoInts = new Add { argLeft = integerA, argRight = integerB };
IPart addTwoFloats = new Add { argLeft = floatA, argRight = floatB };

	IPart addTwoThings = new Add { argLeft = floatA, argRight = integerA };
...</code></pre>

<p>Adding two floats:</p>

<pre><code>float floatResult = addTwoFloats.withFloat;</code></pre>

<p>Adding two integers:</p>

<pre><code>int integerResult = addTwoInts.withInt;</code></pre>

<p>Adding a float and an integer and getting a float:</p>

<pre><code>float floatResult = addTwoThings.withFloat;</code></pre>

<p>Adding two integers and getting a float:</p>

<pre><code>float floatResult = addTowInts.withFloat;</code></pre>

<p>We are now able to support any combination of addition between the primitive data types of floats, strings, integers, arrays, and so on.</p>

<h2 id='why_we_use_with_properties'>Why We Use &#8220;With&#8221; Properties</h2>

<p>Since or framework is used with Interface Vision, we want to be able to visually represent operations without focusing on the primitives we are operating on.</p>

<h3 id='visual_composition'>Visual Composition</h3>

<p>Let&#8217;s see how addition looks visually.</p>
<p class='pagination-centered'><img class='featurette-image img-polaroid' src='/assets/img/doc-overloading-sip-visual-example.png' /> <img /></p>
<p>What is important to note is that the inputs and outputs to our addition configuration do not care about what primitive types we will be adding. By hooking up our Add, we are able to support <strong>all</strong> combinations of addition of primitive types. The actual primitive we operate in depends on which &#8220;with&#8221; property is accessed on the Add part.</p>

<p>A cool thing to note is that this all happens at the &#8220;p-code&#8221; level meaning there is very little to no performance hit.</p>

<h2 id='why_not_use_conversion_inside_operations'>Why Not Use Conversion Inside Operations?</h2>

<p>We could have had a single withPart property and then provided conversion within operations.</p>

<p>However, this would require our code to continually validate that the correct type of data was returned before applying an operation. For example, let&#8217;s say we wanted to implement adding integers and we only have withPart. We would need to do something as follows:</p>

<pre><code>namespace Vision.Core {
  [Serializable] public class AddInteger : OpArgDual {

    [XmlElement(&quot;argLeft&quot;)] public object argLeft { get; set; }
    [XmlElement(&quot;argRight&quot;)] public object argRight { get; set; }

    [XmlIgnore] public override object withPart {
      get {
        int result = 0;
        if (( argLeft is int ) &amp;&amp; ( argRight is int )) {
          result = (int)argLeft + (int)argRight;
        } else {
          // Throw an Exception? Just return 0?
        }
        return result
      }
    }

  }
}</code></pre>

<p>We felt this would greatly slow down execution time: especially in math libraries.</p>

<p>Note: In this pseudo-code, we use object.</p>

<h3 id='how_about_conversion_parts'>How About Conversion Parts</h3>

<p>We could have also created parts to do conversion such as a FloatToInt part. However, we would end up, again, with Part explosion. Also, with a visual integration environment, you would have to use a lot of conversion parts making the program look, visually, messy.</p>

<h3 id='subroutine_explosion'>Subroutine Explosion</h3>

<p>In both examples, conversion within operations and conversion parts, we end up with part explosion: AddLong, AddFloat, AddString, AddFloatLong and so on. Really, if you think about it, overloading is not really the best way to define operations between primitive data types because of this subroutine explosion issue: a real problem in the programming industry.</p>

<p>People do solve this problem to some extent by using things like Generics. Here, for example, are <a href='http://msdn.microsoft.com/en-us/library/ms379564.aspx'>C# Generics</a>.</p>
</div>


      <div>
				<footer>
	        <hr>
	        <div class="navbar">
	          <ul class="nav">
	            <li><a href="http://www.twitter.com/interfacevision" target="_blank">&copy; Interface Vision 2013</a></li>
	            <li><a class="nav-a-social" href="https://plus.google.com/101227313031284036080/posts" target="_blank"><i class="icon-google-color icon-social"></i></a></li>
	            <li><a class="nav-a-social" href="http://www.twitter.com/interfacevision" target="_blank"><i class="icon-twitter-color icon-social"></i></a></li>
	            <li><a class="nav-a-social" href="mailto:chrishylton@interfacevision.com"><i class="icon-mail-color icon-social"></i></a></li>
	          </ul>
	        </div>
	       </footer>
				</div>
    </div>    

    
  </body>
</html>

