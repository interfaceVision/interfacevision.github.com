
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Decorating Properties of Instances</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="How simple interface programming allows you to decorate properties of objects.">
    <meta name="author" content="Eric Hosick">

    <meta property="og:title" content="Interface Vision" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="http://www.interfacevision.com/assets/img/logoFinalStormyDaze122x260.png"/>
    <meta property="og:description" content="How simple interface programming allows you to decorate properties of objects."/>
    <meta property="fb:admins" content="erichosick" />

    <link href='//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css' rel='stylesheet'>    
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <link href="http://fonts.googleapis.com/css?family=Pontano+Sans" rel="stylesheet" type="text/css">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>

  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/"><img src="/assets/img/logoFinalStormyDaze122x260.png"></img></a>
        </div>
      </div>
    </div>


    <div id="image-popup" class="modal hide fade">
      <div class="modal-body">
        <img id="image-to-show"></img>
      </div>
      <div class="modal-footer">
        <a href="#" class="btn btn-primary" data-dismiss="modal">Close</a>
      </div>
    </div>

    <div class="container marketing">
      
<div class="hero-unit">
  <h1 id='decorating_properties_of_instances'>Decorating Properties of Instances</h1>

<h2 id='introduction'>Introduction</h2>

<p>The <a href='http://en.wikipedia.org/wiki/Decorator_pattern'>Decorator Pattern</a> allows you to compose and alter <strong>object</strong> behavior at runtime. This is a powerful design tool to have.</p>

<p>Adding the ability to <strong>decorate the property</strong> of an object would be even more powerful. It would give developers the ability to alter behavior at any point in their program (similar in concept to <a href='http://en.wikipedia.org/wiki/Aspect-oriented_programming'>aspects</a> but at runtime).</p>

<p>How is this done?</p>

<h2 id='review_of_sip_properties'>Review of SIP Properties</h2>

<p>Please take a quick look at our discussion on <a href='/design-sip/design-overloading-sip/'>Overloading</a> if you would like an introduction to how SIP properties work.</p>

<p>Any behavior in SIP is composed of Parts. The composed program below displays the addition of two numbers in a console:</p>

<pre><code>..
IPart addTwoNumbers = new ConsoleWriteLine {
  xml_text = new FloatDefault {
    xml_defaultValue =  new Add {
      xml_argLeft = new Vision.Core.Float { withFloat = 4.3f },
      xml_argRight = new Vision.Core.Float { withFloat = 2.4f }
    }
  }
};
IPart ignore = addTwoNumbers.withPart;
..</code></pre>

<p>the output of this program is:</p>

<pre><code>6.7</code></pre>

<p>The only &#8220;tricky&#8221; part of that program is the FloatDefault part. This part is used to convert the result of the addition from float to string (or we end up concatenating the values as strings resulting in &#8216;4.32.4&#8217; as the output).</p>

<h2 id='the_observer_part'>The Observer Part</h2>

<p>What better way to show how to decorator a property than to show how we can observer (see <a href='http://en.wikipedia.org/wiki/Observer_pattern'>Observer Pattern</a>) any point in our program.</p>

<p>Let&#8217;s provide some pseudo-code on the Observer part:</p>

<pre><code>public class Observer : PartParent {
  public Part xml_property { get; set; }
  public Part xml_actionBeforeGet { get; set; }
  public Part xml_actionAfterGet { get; set; }

  public override IPart withPart {
    get {
      IPart ignore = actionBeforeGet.withPart;
      IPart result = property.withPart;
      ignore = actionAfterGet.withPart;
      return result;
    }
  }

  public override float withFloat {
    get {
      IPart ignore = actionBeforeGet.withPart;
      float result = property.withFloat;
      ignore = actionAfterGet.withPart;
      return result;
    }
  }
  ....
}</code></pre>

<p>The property xml_property contains the part, and thus access to the property, that we are going to observe. The actions we take before and after a property is accessed is configured in the xml_actionBeforeGet and xml_actionAfterGet properties respectively. The logic for each with property is the same:</p>

<p>Run the action before we access the property:</p>

<pre><code>IPart ignore = actionBeforeGet.withPart;</code></pre>

<p>Use the property</p>

<pre><code>float result = property.withFloat;</code></pre>

<p>Run the action after we access the property.</p>

<pre><code>ignore = actionAfterGet.withPart;</code></pre>

<p>Finally, return the result of the get.</p>

<pre><code>return result;</code></pre>

<p>We are now able to inject an observer anywhere within our program during run-time. Woo hoo! Note the observer, in this case, is passive. We should not alter the flow of the program in any way: just observe.</p>

<h2 id='putting_it_all_together'>Putting it All Together</h2>

<p>Let&#8217;s print some text letting the user know we are accessing the argLeft property of Add.</p>

<pre><code>..
IPart addTwoNumbers = new ConsoleWriteLine {
  xml_text = new FloatDefault {
    xml_defaultValue = new Add {
      xml_argLeft = new Observer {
          xml_property = new Float { withFloat = 4.3f },
          xml_actionBeforeGet = new ConsoleWriteLine {
	          xml_text = new String { withString = &quot;The Add&#39;s argLeft property will be accessed.&quot; }
        },
      xml_argRight = new Float { withFloat = 2.4f }
    }
  }
};

IPart ignore = addTwoNumbers.withPart;
..</code></pre>

<p>the output of this program is:</p>

<pre><code>The Add&#39;s argLeft property will be accessed.
6.7</code></pre>

<p>The interesting point to notice is that the Observer is injected between xml_argLeft of Add and the Float Part which has a value of 4.3.</p>

<h2 id='visually_representing_decorators'>Visually Representing Decorators</h2>

<p>We should be able to represent decorators as &#8220;hooks&#8221; into our visual object language. The hook looks like a &#8220;current loop&#8221; - a device that wraps around a wire to monitor how much current flows through the wire.</p>
<p class='pagination-centered'><img class='featurette-image img-polaroid' src='/assets/img/design-decorating-properties-observer.png' /> <img /></p>
<p>We don&#8217;t want to clutter up our original add program by visually injecting the Observer into our program. Instead, we are able to &#8220;attach&#8221; it to the program, as you would attaching any monitoring device to a circuit (for example).</p>

<h2 id='cool_examples_of_decorating_properties'>Cool Examples of Decorating Properties</h2>

<p>Note that we can do all of this while the program is running: no need to code, build, and then run the program.</p>

<ol>
<li>We could wrap any property of a program using a Timer part letting us know how much CPU time is used by a particular property whenever it is called.</li>

<li>We can notify other parts of a program when a property was accessed allowing us to add &#8220;onX&#8221; events anywhere in the program.</li>

<li>We can debug parts of a program during runtime without altering the existing behavior (because the observer is passive): even in production if need be.</li>

<li>We can inject logic to monitor things like conversions (of customers for example) without altering the existing behavior of our program.</li>

<li>We can inject single event triggers in our program that remove themselves from the program once they trigger.</li>

<li>We can create Agents that inject behavior within a program to monitor different parts of a program.</li>
</ol>
</div>


      <div>
				<footer>
	        <hr>
	        <div class="navbar">
	          <ul class="nav">
	            <li><a href="http://www.twitter.com/interfacevision" target="_blank">&copy; Interface Vision 2013</a></li>
	            <li><a class="nav-a-social" href="https://plus.google.com/101227313031284036080/posts" target="_blank"><i class="icon-google-color icon-social"></i></a></li>
	            <li><a class="nav-a-social" href="http://www.twitter.com/interfacevision" target="_blank"><i class="icon-twitter-color icon-social"></i></a></li>
	            <li><a class="nav-a-social" href="mailto:chrishylton@interfacevision.com"><i class="icon-mail-color icon-social"></i></a></li>
	          </ul>
	        </div>
	       </footer>
				</div>
    </div>    

    
  </body>
</html>

