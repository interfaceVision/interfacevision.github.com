<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Interface Vision</title>
 <link href="http://bloginterfacevision.github.com/atom.xml" rel="self"/>
 <link href="http://bloginterfacevision.github.com"/>
 <updated>2012-12-03T17:17:37+07:00</updated>
 <id>http://bloginterfacevision.github.com</id>
 <author>
   <name>Eric Hosick</name>
   <email>erichosick@interfacevision.com</email>
 </author>

 
 <entry>
   <title>Decorating Properties of Instances</title>
   <link href="http://bloginterfacevision.github.com/design-sip/design-decorating-properties"/>
   <updated>2012-12-03T00:00:00+07:00</updated>
   <id>http://bloginterfacevision.github.com/design-sip/design-decorating-properties</id>
   <content type="html">&lt;h1 id='decorating_properties_of_instances'&gt;Decorating Properties of Instances&lt;/h1&gt;

&lt;h2 id='introduction'&gt;Introduction&lt;/h2&gt;

&lt;p&gt;The &lt;a href='http://en.wikipedia.org/wiki/Decorator_pattern'&gt;Decorator Pattern&lt;/a&gt; allows you to compose and alter &lt;strong&gt;object&lt;/strong&gt; behavior at runtime. This is a powerful design tool to have.&lt;/p&gt;

&lt;p&gt;Adding the ability to &lt;strong&gt;decorate the property&lt;/strong&gt; of an object would be even more powerful. It would give developers the ability to alter behavior at any point in their program (similar in concept to &lt;a href='http://en.wikipedia.org/wiki/Aspect-oriented_programming'&gt;aspects&lt;/a&gt; but at runtime).&lt;/p&gt;

&lt;p&gt;How is this done?&lt;/p&gt;

&lt;h2 id='review_of_sip_properties'&gt;Review of SIP Properties&lt;/h2&gt;

&lt;p&gt;Please take a quick look at our discussion on &lt;a href='/design-sip/design-overloading-sip/'&gt;Overloading&lt;/a&gt; if you would like an introduction to how SIP properties work.&lt;/p&gt;

&lt;p&gt;Any behavior in SIP is composed of Parts. The composed program below displays the addition of two numbers in a console:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;..
IPart addTwoNumbers = new ConsoleWriteLine {
  xml_text = new FloatDefault {
    xml_defaultValue =  new Add {
      xml_argLeft = new Vision.Core.Float { withFloat = 4.3f },
      xml_argRight = new Vision.Core.Float { withFloat = 2.4f }
    }
  }
};
IPart ignore = addTwoNumbers.withPart;
..&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the output of this program is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;6.7&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only &amp;#8220;tricky&amp;#8221; part of that program is the FloatDefault part. This part is used to convert the result of the addition from float to string (or we end up concatenating the values as strings resulting in &amp;#8216;4.32.4&amp;#8217; as the output).&lt;/p&gt;

&lt;h2 id='the_observer_part'&gt;The Observer Part&lt;/h2&gt;

&lt;p&gt;What better way to show how to decorator a property than to show how we can observer (see &lt;a href='http://en.wikipedia.org/wiki/Observer_pattern'&gt;Observer Pattern&lt;/a&gt;) any point in our program.&lt;/p&gt;

&lt;p&gt;Let&amp;#8217;s provide some pseudo-code on the Observer part:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Observer : PartParent {
  public Part xml_property { get; set; }
  public Part xml_actionBeforeGet { get; set; }
  public Part xml_actionAfterGet { get; set; }

  public override IPart withPart {
    get {
      IPart ignore = actionBeforeGet.withPart;
      IPart result = property.withPart;
      ignore = actionAfterGet.withPart;
      return result;
    }
  }

  public override float withFloat {
    get {
      IPart ignore = actionBeforeGet.withPart;
      float result = property.withFloat;
      ignore = actionAfterGet.withPart;
      return result;
    }
  }
  ....
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The property xml_property contains the part, and thus access to the property, that we are going to observe. The actions we take before and after a property is accessed is configured in the xml_actionBeforeGet and xml_actionAfterGet properties respectively. The logic for each with property is the same:&lt;/p&gt;

&lt;p&gt;Run the action before we access the property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IPart ignore = actionBeforeGet.withPart;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use the property&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float result = property.withFloat;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the action after we access the property.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ignore = actionAfterGet.withPart;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, return the result of the get.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return result;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are now able to inject an observer anywhere within our program during run-time. Woo hoo! Note the observer, in this case, is passive. We should not alter the flow of the program in any way: just observe.&lt;/p&gt;

&lt;h2 id='putting_it_all_together'&gt;Putting it All Together&lt;/h2&gt;

&lt;p&gt;Let&amp;#8217;s print some text letting the user know we are accessing the argLeft property of Add.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;..
IPart addTwoNumbers = new ConsoleWriteLine {
  xml_text = new FloatDefault {
    xml_defaultValue = new Add {
      xml_argLeft = new Observer {
          xml_property = new Float { withFloat = 4.3f },
          xml_actionBeforeGet = new ConsoleWriteLine {
	          xml_text = new String { withString = &amp;quot;The Add&amp;#39;s argLeft property will be accessed.&amp;quot; }
        },
      xml_argRight = new Float { withFloat = 2.4f }
    }
  }
};

IPart ignore = addTwoNumbers.withPart;
..&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the output of this program is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;The Add&amp;#39;s argLeft property will be accessed.
6.7&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The interesting point to notice is that the Observer is injected between xml_argLeft of Add and the Float Part which has a value of 4.3.&lt;/p&gt;

&lt;h2 id='visually_representing_decorators'&gt;Visually Representing Decorators&lt;/h2&gt;

&lt;p&gt;We should be able to represent decorators as &amp;#8220;hooks&amp;#8221; into our visual object language. The hook looks like a &amp;#8220;current loop&amp;#8221; - a device that wraps around a wire to monitor how much current flows through the wire.&lt;/p&gt;
&lt;p class='pagination-centered'&gt;&lt;img class='featurette-image img-polaroid' src='/assets/img/design-decorating-properties-observer.png' /&gt; &lt;img /&gt;&lt;/p&gt;
&lt;p&gt;We don&amp;#8217;t want to clutter up our original add program by visually injecting the Observer into our program. Instead, we are able to &amp;#8220;attach&amp;#8221; it to the program, as you would attaching any monitoring device to a circuit (for example).&lt;/p&gt;

&lt;h2 id='cool_examples_of_decorating_properties'&gt;Cool Examples of Decorating Properties&lt;/h2&gt;

&lt;p&gt;Note that we can do all of this while the program is running: no need to code, build, and then run the program.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;We could wrap any property of a program using a Timer part letting us know how much CPU time is used by a particular property whenever it is called.&lt;/li&gt;

&lt;li&gt;We can notify other parts of a program when a property was accessed allowing us to add &amp;#8220;onX&amp;#8221; events anywhere in the program.&lt;/li&gt;

&lt;li&gt;We can debug parts of a program during runtime without altering the existing behavior (because the observer is passive): even in production if need be.&lt;/li&gt;

&lt;li&gt;We can inject logic to monitor things like conversions (of customers for example) without altering the existing behavior of our program.&lt;/li&gt;

&lt;li&gt;We can inject single event triggers in our program that remove themselves from the program once they trigger.&lt;/li&gt;

&lt;li&gt;We can create Agents that inject behavior within a program to monitor different parts of a program.&lt;/li&gt;
&lt;/ol&gt;</content>
 </entry>
 
 <entry>
   <title>Why We Don't Need Overloading</title>
   <link href="http://bloginterfacevision.github.com/design-sip/design-overloading-sip"/>
   <updated>2012-11-26T00:00:00+07:00</updated>
   <id>http://bloginterfacevision.github.com/design-sip/design-overloading-sip</id>
   <content type="html">&lt;h1 id='why_we_dont_use_overloading'&gt;Why We Don&amp;#8217;t Use Overloading&lt;/h1&gt;

&lt;h2 id='introduction'&gt;Introduction&lt;/h2&gt;

&lt;p&gt;We don&amp;#8217;t use overloading because our framework has no subroutines to overload. This is because the rules of Simple Interface Programming (SIP) don&amp;#8217;t allow subroutines with explicit parameters.&lt;/p&gt;

&lt;p&gt;Instead of overloading, we use Parts that are able to operate on all primitives. Currently, we have chosen Part (aka object), string, boolean, integer, long, float, double, byte&amp;#91;&amp;#93;, int&amp;#91;&amp;#93;, long&amp;#91;&amp;#93; and float&amp;#91;&amp;#93; as the primitives we support.&lt;/p&gt;

&lt;h2 id='example_of_traditional_overloading'&gt;Example of Traditional Overloading&lt;/h2&gt;

&lt;p&gt;The following is how, traditionally, the function add would be defined for different primitives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
int add (int left, int right ) { return left + right }
long add (long left, int right) { return left = right }
long add (long left, long right) { return left + right }
...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and so on. The left and right parameters for add vary based on the primitives we need to add. This is known as overloading: specifically we have overloaded the subroutine add.&lt;/p&gt;

&lt;h2 id='how_we_overload_subroutines'&gt;How We &amp;#8220;Overload&amp;#8221; Subroutines&lt;/h2&gt;

&lt;p&gt;Our Part part use &amp;#8220;with&amp;#8221; Properties: each &amp;#8220;with&amp;#8221; property being of a different primitive data type. Here is the pseudo-code for our Part part (note we are only showing withPart, withInt and withFloat).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Serializable] public class Part : IPart {
  ...
  [XmlIgnore] public virtual IPart withPart { get; set; }
  [XmlIgnore] public virtual int   withInt { get; set; }
  [XmlIgnore] public virtual float withFloat { get; set; }
  ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default, these properties do nothing for the set scope and return a &amp;#8220;default value&amp;#8221; for the get scope: usually 0, false, empty string, empty part and 0 length arrays.&lt;/p&gt;

&lt;p&gt;Every Part that inherits from the Part class can optionally implement a &amp;#8220;with&amp;#8221; property.&lt;/p&gt;

&lt;p&gt;Note: The Part class is our framework&amp;#8217;s &amp;#8220;object&amp;#8221; from which everything inherits. At some point, we will update the C# object class to contain &amp;#8220;with&amp;#8221; properties.&lt;/p&gt;

&lt;h2 id='example_primitive_parts'&gt;Example Primitive Parts&lt;/h2&gt;

&lt;p&gt;Let&amp;#8217;s look at pseudo-code for the Float and Integer part. Our Float and Integer parts implements the &amp;#8220;with&amp;#8221; properties as follows:&lt;/p&gt;

&lt;h3 id='float_part'&gt;Float Part&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;namespace Vision.Core {

  [Serializable] public class Float : Part {
    protected float p_value = 0.0f;
    [XmlElement(&amp;quot;value&amp;quot;)] public override float withFloat {
      get { return p_value; }
      set { p_value = value; }
    }

    [XmlIgnore] public override int withInt {
      get { return (int)p_value; }
      set { p_value = value; }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our Float Part is able to convert to different primitive types automatically (note this is pseudo-code and more validation occurs in the actual source code).&lt;/p&gt;

&lt;p&gt;Note: At some point we will update object of C# to contain with properties. The example Float part would be removed and the float type would be updated. This allows us to take advantage of boxing, etc.&lt;/p&gt;

&lt;h3 id='integer_part'&gt;Integer Part&lt;/h3&gt;

&lt;p&gt;The Integer Part looks almost similar to the Float part.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace Vision.Core {
  [Serializable] public class Integer : Part {

    protected int p_value = 0;
    [XmlElement(&amp;quot;value&amp;quot;)] public override int withInt {
      get { return p_value; }
      set { p_value = value; }
    }

    [XmlIgnore] public override float withFloat {
      get { return (float)withInt; }
      set { withInt = (int)value; }
    }

  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='operations'&gt;Operations&lt;/h2&gt;

&lt;p&gt;So, we have our primitives defined. Let&amp;#8217;s look at how we bypass the need for Overloading by implementing an Add Part.&lt;/p&gt;

&lt;h3 id='add_part'&gt;Add Part&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;namespace Vision.Core {
  [Serializable] public class Add : OpArgDual {

    [XmlElement(&amp;quot;argLeft&amp;quot;)] public Part argLeft { get; set; }
    [XmlElement(&amp;quot;argRight&amp;quot;)] public Part argRight { get; set; }

    [XmlIgnore] public override int withInt {
      get { return argLeft.withInt + argRight.withInt; }
    }

    [XmlIgnore] public override float withFloat {
      get {
        return argLeft.withFloat + argRight.withFloat;
      }
    }

  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What is most interesting to note is that each &amp;#8220;with&amp;#8221; Property calls the associated &amp;#8220;with&amp;#8221; property of argLeft and argRight and then adds them. For example, withFloat is implemented as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return argLeft.withFloat + argRight.withFloat;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='putting_it_all_together'&gt;Putting it All Together&lt;/h2&gt;

&lt;p&gt;Let&amp;#8217;s see how we are able to use operations on different primitive types without Overloading. First, we will setup a few variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
IPart integerA = new Integer { withInt = 3 };
IPart integerB = new Integer { withInt = 4 };
IPart floatA = new Float { withFloat = 3.0f };
IPart floatB = new Float { withFloat = 3.0f };

IPart addTwoInts = new Add { argLeft = integerA, argRight = integerB };
IPart addTwoFloats = new Add { argLeft = floatA, argRight = floatB };

	IPart addTwoThings = new Add { argLeft = floatA, argRight = integerA };
...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding two floats:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float floatResult = addTwoFloats.withFloat;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding two integers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int integerResult = addTwoInts.withInt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding a float and an integer and getting a float:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float floatResult = addTwoThings.withFloat;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Adding two integers and getting a float:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float floatResult = addTowInts.withFloat;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are now able to support any combination of addition between the primitive data types of floats, strings, integers, arrays, and so on.&lt;/p&gt;

&lt;h2 id='why_we_use_with_properties'&gt;Why We Use &amp;#8220;With&amp;#8221; Properties&lt;/h2&gt;

&lt;p&gt;Since or framework is used with Interface Vision, we want to be able to visually represent operations without focusing on the primitives we are operating on.&lt;/p&gt;

&lt;h3 id='visual_composition'&gt;Visual Composition&lt;/h3&gt;

&lt;p&gt;Let&amp;#8217;s see how addition looks visually.&lt;/p&gt;
&lt;p class='pagination-centered'&gt;&lt;img class='featurette-image img-polaroid' src='/assets/img/doc-overloading-sip-visual-example.png' /&gt; &lt;img /&gt;&lt;/p&gt;
&lt;p&gt;What is important to note is that the inputs and outputs to our addition configuration do not care about what primitive types we will be adding. By hooking up our Add, we are able to support &lt;strong&gt;all&lt;/strong&gt; combinations of addition of primitive types. The actual primitive we operate in depends on which &amp;#8220;with&amp;#8221; property is accessed on the Add part.&lt;/p&gt;

&lt;p&gt;A cool thing to note is that this all happens at the &amp;#8220;p-code&amp;#8221; level meaning there is very little to no performance hit.&lt;/p&gt;

&lt;h2 id='why_not_use_conversion_inside_operations'&gt;Why Not Use Conversion Inside Operations?&lt;/h2&gt;

&lt;p&gt;We could have had a single withPart property and then provided conversion within operations.&lt;/p&gt;

&lt;p&gt;However, this would require our code to continually validate that the correct type of data was returned before applying an operation. For example, let&amp;#8217;s say we wanted to implement adding integers and we only have withPart. We would need to do something as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace Vision.Core {
  [Serializable] public class AddInteger : OpArgDual {

    [XmlElement(&amp;quot;argLeft&amp;quot;)] public object argLeft { get; set; }
    [XmlElement(&amp;quot;argRight&amp;quot;)] public object argRight { get; set; }

    [XmlIgnore] public override object withPart {
      get {
        int result = 0;
        if (( argLeft is int ) &amp;amp;&amp;amp; ( argRight is int )) {
          result = (int)argLeft + (int)argRight;
        } else {
          // Throw an Exception? Just return 0?
        }
        return result
      }
    }

  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We felt this would greatly slow down execution time: especially in math libraries.&lt;/p&gt;

&lt;p&gt;Note: In this pseudo-code, we use object.&lt;/p&gt;

&lt;h3 id='how_about_conversion_parts'&gt;How About Conversion Parts&lt;/h3&gt;

&lt;p&gt;We could have also created parts to do conversion such as a FloatToInt part. However, we would end up, again, with Part explosion. Also, with a visual integration environment, you would have to use a lot of conversion parts making the program look, visually, messy.&lt;/p&gt;

&lt;h3 id='subroutine_explosion'&gt;Subroutine Explosion&lt;/h3&gt;

&lt;p&gt;In both examples, conversion within operations and conversion parts, we end up with part explosion: AddLong, AddFloat, AddString, AddFloatLong and so on. Really, if you think about it, overloading is not really the best way to define operations between primitive data types because of this subroutine explosion issue: a real problem in the programming industry.&lt;/p&gt;

&lt;p&gt;People do solve this problem to some extent by using things like Generics. Here, for example, are &lt;a href='http://msdn.microsoft.com/en-us/library/ms379564.aspx'&gt;C# Generics&lt;/a&gt;.&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>Defining and Using Properties in SIP</title>
   <link href="http://bloginterfacevision.github.com/design-sip/design-general-sip-properties"/>
   <updated>2012-11-25T00:00:00+07:00</updated>
   <id>http://bloginterfacevision.github.com/design-sip/design-general-sip-properties</id>
   <content type="html">&lt;h1 id='defining_and_using_properties_in_sip'&gt;Defining and Using Properties in SIP&lt;/h1&gt;

&lt;h2 id='introduction'&gt;Introduction&lt;/h2&gt;

&lt;p&gt;A property in Simple Interface Programming (SIP) is different from attributes or traditional properties.&lt;/p&gt;

&lt;p&gt;A SIP property can contain a part instance and software behavior.&lt;/p&gt;

&lt;p&gt;As such, accessing a SIP property will:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;return a part located in that property.&lt;/li&gt;

&lt;li&gt;run behavior contained within the property.&lt;/li&gt;

&lt;li&gt;both locate a part and run the behavior on the part.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id='defining_properties_in_sip'&gt;Defining Properties in SIP&lt;/h2&gt;

&lt;p&gt;Two steps are required to define a SIP property.&lt;/p&gt;

&lt;h3 id='step_1__persisting_properties'&gt;Step 1 - Persisting Properties&lt;/h3&gt;

&lt;p&gt;First, we define how the property is persisted.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private ItemClass p_propertySip = Empty.instanceStatic;
[XmlElement(&amp;quot;propertySip&amp;quot;)] public ItemClass xml_propertySip {
  get { return p_propertySip; }
  set {
    p_propertySip = (null != value) ? value : Empty.instanceStatic;
    p_propertySip.parentDirect = this;
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every SIP property has an XmlElement with a property name of xml_propertySip where propertySip is the name of the property. The Name of the element is almost always the same as the name of the property (in this case propertySip).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[XmlElement(&amp;quot;propertySip&amp;quot;)] public ItemClass xml_propertySip { ... }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The get scope of the property always returns the part located in p_propertySip as seen here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;get { return p_propertySip; }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where p_propertySip is defined as:&lt;/p&gt;

&lt;p&gt;private ItemClass p_propertySip = Empty.instanceStatic;&lt;/p&gt;

&lt;p&gt;Setting a SIP property involves setting the p_propertySip property and the properties parent part.&lt;/p&gt;

&lt;p&gt;A SIP property can &lt;strong&gt;never&lt;/strong&gt; be null. As such, on setting the property, we check for null and set the instance to an Empty part if null was passed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p_propertySip = (null != value) ? value : Empty.instanceStatic;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The part placed within a SIP property has a &amp;#8220;parent&amp;#8221; or another part that owns the part. As such, we set the parent of the new property to the current Part:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p_propertySip.parentDirect = this;&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='step_2__accessing_properties'&gt;Step 2 - Accessing Properties&lt;/h3&gt;

&lt;p&gt;Second, we need to describe how to access the persisted property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[XmlIgnore] public IPart propertySip {
  get { return xml_propertySip.callWith ? xml_propertySip.withItem : xml_propertySip; }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You almost always access a SIP property through this property. Here is where we decide if we return a Part, run the behavior of a Part or do both.&lt;/p&gt;

&lt;p&gt;The callWith property of every Part is, by default, true. That means the behavior will always be called on a Part unless callWith is overridden. When overridden, and set to false, the access a property will return the part persisted in xml_propertySip.&lt;/p&gt;

&lt;h3 id='putting_it_all_together'&gt;Putting It All Together&lt;/h3&gt;

&lt;p&gt;Here is an example of a fully defined SIP property named variables.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	[XmlIgnore] public IPart variables {
		get { xml_variables.callWith ? xml_variables.withItem : xml_variables; }
	}
	
	private ItemClass p_variables = Empty.instanceStatic;
	[XmlElement(&amp;quot;variables&amp;quot;)] public ItemClass xml_variables {
		get { return p_variables; }
		set {
			p_variables = (null != value) ? value : Empty.instanceStatic;
			p_variables.parentDirect = this;
		}
	}&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id='using_properties_in_sip'&gt;Using Properties in SIP&lt;/h2&gt;

&lt;h3 id='creating_a_part_instance'&gt;Creating a Part Instance&lt;/h3&gt;

&lt;p&gt;When programmatically creating a part, you use the xml_propertySip. An example of creating a Template part is provided:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
IPart template = new Template {
  xml_variables = new FloatNamed { name = &amp;quot;some name&amp;quot;, value = 4.0 },
  xml_action = new ...
}
...&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='using_a_property'&gt;Using a Property&lt;/h3&gt;

&lt;p&gt;When programming, you use a property by simply accessing the property like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
IPart variablesFound = template.variables;
...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example code along with the above example code, since callWith is true, the withItem of the Part located in xml_variables is called. This happens to be a FloatNamed which, when withItem is called, returns an instance of itself.&lt;/p&gt;

&lt;h2 id='improving_access_time'&gt;Improving Access Time&lt;/h2&gt;

&lt;p&gt;In some cases, your property may always want to run withItem of the Part placed in a property. In this case, we can simplify the implementation as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[XmlIgnore] public IPart propertySip {
  get { return xml_propertySip.withItem; }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;#8217;s consider an add Part which contains a left and right argument. Add and is defined as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;namespace Vision.Core {
  [Serializable] public class OpArgDual : Part, IArgDouble {
    [XmlIgnore] public IPart argLeft {
      get { return xml_argLeft.withItem; }
    }

    private ItemClass p_argLeft = Empty.instanceStatic;
    [XmlElement(&amp;quot;argLeft&amp;quot;)] public ItemClass xml_argLeft {
      get { return p_argLeft; }
      set {
        p_argLeft = (null != value) ? value : Empty.instanceStatic;
        p_argLeft.parentDirect = this;
      }
    }

    [XmlIgnore] public IPart argRight {
      get { return xml_argRight.withItem; }
    }

    private ItemClass p_argRight = Empty.instanceStatic;
    [XmlElement(&amp;quot;argRight&amp;quot;)] public ItemClass xml_argRight {
      get { return p_argRight; }
      set {
        p_argRight = (null != value) ? value : Empty.instanceStatic;
        p_argRight.parentDirect = this;
      }
    }
  }

  [Serializable] public class Add : OpArgDual {
    [XmlIgnore] public override int withInt {
      get {
        return argLeft.withInt + argRight.withInt;
      }
    }
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, we always need to use the value of argLeft or argRight when doing mathematical operations with left and right arguments. We never want to return the Part and use it in some way. So, in this case, we can simplify the get scope of argLeft and argRight directly accessing the persisted xml_argLeft.withItem (or xml_argRight.withItem).&lt;/p&gt;

&lt;h2 id='why_not_use_macros_to_define_a_property'&gt;Why Not Use Macros To Define A Property?&lt;/h2&gt;

&lt;p&gt;We don&amp;#8217;t use macros because C# does not support macros &lt;a href='http://blogs.msdn.com/b/csharpfaq/archive/2004/03/09/86979.aspx'&gt;Why doesn&amp;#8217;t C# support #define macros?&lt;/a&gt;&lt;/p&gt;</content>
 </entry>
 
 
</feed>